Dependencies to Install:

bash
npm install next-auth mongoose bcryptjs
1. MongoDB Connection (lib/mongodb.js)
javascript
import mongoose from "mongoose";

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) throw new Error("Please define the MONGODB_URI environment variable");

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function connectDB() {
  if (cached.conn) return cached.conn;
  if (!cached.promise) {
    cached.promise = mongoose.connect(MONGODB_URI, { bufferCommands: false }).then((mongoose) => mongoose);
  }
  cached.conn = await cached.promise;
  return cached.conn;
}

export default connectDB;
2. User Schema (models/User.js)
javascript
import mongoose from "mongoose";

const UserSchema = new mongoose.Schema({
  email: { type: String, unique: true, required: true },
  password: { type: String, required: true },
  name: { type: String }
});

export default mongoose.models.User || mongoose.model("User", UserSchema);
3. NextAuth Configuration (pages/api/auth/[...nextauth].js)
javascript
import NextAuth from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import connectDB from "../../../lib/mongodb";
import User from "../../../models/User";
import bcrypt from "bcryptjs";

export default NextAuth({
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "text" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        await connectDB();
        const user = await User.findOne({ email: credentials.email }).select("+password");
        if (!user) throw new Error("Invalid email or password");
        const isValid = await bcrypt.compare(credentials.password, user.password);
        if (!isValid) throw new Error("Invalid email or password");
        return { id: user._id, email: user.email, name: user.name };
      }
    })
  ],
  session: { strategy: "jwt" },
  pages: { signIn: "/login" },
  secret: process.env.NEXTAUTH_SECRET
});
4. Registration API Route (pages/api/auth/register.js)
javascript
import connectDB from "../../../lib/mongodb";
import User from "../../../models/User";
import bcrypt from "bcryptjs";

export default async function handler(req, res) {
  if (req.method !== "POST") return res.status(405).end();
  const { email, password, name } = req.body;
  await connectDB();
  const existingUser = await User.findOne({ email });
  if (existingUser) return res.status(400).json({ message: "User already exists" });
  const hashedPassword = await bcrypt.hash(password, 10);
  const user = await User.create({ email, password: hashedPassword, name });
  res.status(201).json({ message: "User created", user: { email: user.email, name: user.name } });
}
5. Sample Sign-Up Form (React Component)
javascript
import { useState } from "react";

export default function Register() {
  const [form, setForm] = useState({ email: "", password: "", name: "" });
  const [error, setError] = useState("");

  async function handleSubmit(e) {
    e.preventDefault();
    setError("");
    const res = await fetch("/api/auth/register", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(form)
    });
    const data = await res.json();
    if (!res.ok) setError(data.message);
    else window.location.href = "/login";
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" placeholder="Name" value={form.name} onChange={e => setForm({ ...form, name: e.target.value })} required />
      <input type="email" placeholder="Email" value={form.email} onChange={e => setForm({ ...form, email: e.target.value })} required />
      <input type="password" placeholder="Password" value={form.password} onChange={e => setForm({ ...form, password: e.target.value })} required />
      <button type="submit">Register</button>
      {error && <p>{error}</p>}
    </form>
  );
}
6. Sample Login Form (React Component)
javascript
import { signIn } from "next-auth/react";
import { useState } from "react";

export default function Login() {
  const [form, setForm] = useState({ email: "", password: "" });
  const [error, setError] = useState("");

  async function handleSubmit(e) {
    e.preventDefault();
    setError("");
    const res = await signIn("credentials", {
      redirect: false,
      email: form.email,
      password: form.password
    });
    if (res.error) setError(res.error);
    else window.location.href = "/";
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" placeholder="Email" value={form.email} onChange={e => setForm({ ...form, email: e.target.value })} required />
      <input type="password" placeholder="Password" value={form.password} onChange={e => setForm({ ...form, password: e.target.value })} required />
      <button type="submit">Login</button>
      {error && <p>{error}</p>}
    </form>
  );
}










Absolutely! Here‚Äôs a corrected and integrated set of your main files so that all data shapes and function contracts are consistent.
This will ensure your app works smoothly with both dummy and DB tweets.

1. /app/tweet/page.js (TweetsList)
"use client";
import { useState, useEffect } from "react";
import TweetCard from "@/components/TweetCard";
import TweetForm from "@/components/TweetForm";
import Link from "next/link";

export default function TweetsList() {
  const [tweets, setTweets] = useState([]);
  const [isModalOpen, setModalOpen] = useState(false);

  // Normalize all tweets to a common shape
  const normalizeTweet = (tweet) => ({
    id: tweet.id || tweet._id,
    title: tweet.title || tweet.tweetContent || "",
    body: tweet.body || "",
    tags: tweet.tags || [],
    reactions:
      typeof tweet.reactions === "object"
        ? tweet.reactions
        : { likes: tweet.reactions || 0, dislikes: 0 },
    views: tweet.views || 0,
    twitterUser: tweet.twitterUser || "Anonymous",
  });

  // Fetch tweets from both sources and merge
  useEffect(() => {
    const fetchAllTweets = async () => {
      try {
        // Fetch dummy posts
        const dummyRes = await fetch("/api/dummyPost", { method: "POST" });
        const dummyData = await dummyRes.json();
        const dummyPosts = dummyData.posts.map(normalizeTweet);

        // Fetch DB tweets
        const dbRes = await fetch("/api/tweets");
        const dbJson = await dbRes.json();
        const dbTweets = (dbJson.data || []).map(normalizeTweet);

        // Merge and set
        setTweets([...dbTweets, ...dummyPosts]);
      } catch (error) {
        console.error("Error fetching data:", error);
      }
    };
    fetchAllTweets();
  }, []);

  // Handle new tweet submission
  const handlePostSubmit = async ({ twitterUser, tweetContent }) => {
    try {
      const res = await fetch("/api/tweets", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ twitterUser, tweetContent }),
      });
      if (!res.ok) throw new Error("Failed to post tweet");
      const result = await res.json();
      const newTweet = normalizeTweet(result.data);
      setTweets((prev) => [newTweet, ...prev]);
    } catch (err) {
      console.error(err);
      alert("Failed to post tweet");
    }
  };

  return (
    <>
      <TweetForm
        isOpen={isModalOpen}
        onClose={() => setModalOpen(false)}
        onSubmit={handlePostSubmit}
      />

      <button
        className="w-full bg-black text-white rounded-[10px] font-bold py-2 px-4 mt-4 mb-4 cursor-pointer"
        onClick={() => setModalOpen(true)}
      >
        Make a post!
      </button>
      <div>
        {tweets.map((tweet) => (
          <Link key={tweet.id} href={`/tweet/${tweet.id}`}>
            <TweetCard tweet={tweet} />
          </Link>
        ))}
      </div>
    </>
  );
}
2. /app/api/dummyPost/route.js

export default async function handler(req, res) {
  try {
    const dummyJsonRes = await fetch("https://dummyjson.com/posts");
    const dummyJsonData = await dummyJsonRes.json();
    res.status(200).json(dummyJsonData);
  } catch (error) {
    console.error('Error fetching posts:', error);
    res.status(500).json({ error: 'Failed to fetch posts' });
  }
}
3. /app/api/tweets/route.js (DB API Route)

import { NextResponse } from "next/server";
import { makeSureDbIsReady } from "@/lib/dataBase";
import Tweet from "@/models/Tweet";
import jwt from "jsonwebtoken";

// GET /api/tweets
export async function GET() {
  try {
    await makeSureDbIsReady();
    const tweets = await Tweet.find().sort({ createdAt: -1 });
    return NextResponse.json({ success: true, data: tweets }, { status: 200 });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

// POST /api/tweets
export async function POST(request) {
  try {
    await makeSureDbIsReady();
    const token = request.cookies.get("token")?.value;
    let username = "New User";
    if (token) {
      try {
        const { username: jwtUsername } = jwt.verify(token, process.env.JWT_SECRET);
        username = jwtUsername;
      } catch {}
    }
    const { twitterUser, tweetContent } = await request.json();
    if (!tweetContent) {
      return NextResponse.json(
        { success: false, error: "Tweet content is required" },
        { status: 400 }
      );
    }
    const newTweet = await Tweet.create({ twitterUser: twitterUser || username, tweetContent });
    return NextResponse.json(
      { success: true, data: newTweet.toObject() },
      { status: 201 }
    );
  } catch (error) {
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
4. TweetForm.js

"use client";
import React, { useState } from "react";

export default function TweetForm({ isOpen, onClose, onSubmit }) {
  const [tweetContent, setTweetContent] = useState("");
  const [twitterUser, setTwitterUser] = useState("New User");

  if (!isOpen) return null;

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!tweetContent.trim()) {
      alert("Please enter some text!");
      return;
    }
    onSubmit({ twitterUser, tweetContent });
    setTweetContent("");
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-6 rounded shadow-lg w-full max-w-md">
        <form onSubmit={handleSubmit}>
          <input
            className="input"
            type="text"
            name="twitterUser"
            value={twitterUser}
            onChange={(e) => setTwitterUser(e.target.value)}
            placeholder="Your Name"
          />
          <textarea
            name="tweetContent"
            id="content"
            placeholder="What's happening?"
            className="w-full bg-transparent border rounded p-4 mb-4"
            rows={3}
            value={tweetContent}
            onChange={(e) => setTweetContent(e.target.value)}
            required
          />
          <button
            type="submit"
            className="px-4 py-2 h-[50px] bg-[#50b7f5] rounded-[20px] text-white font-bold text-[18px] border-none mt-5 cursor-pointer transition-colors duration-200 hover:bg-[#1da1f2]"
            disabled={!tweetContent.trim()}
          >
            Tweet
          </button>
          <button
            type="button"
            onClick={onClose}
            className="px-4 py-2 h-[50px] bg-[#50b7f5] rounded-[20px] text-white font-bold text-[18px] border-none mt-5 cursor-pointer transition-colors duration-200 hover:bg-[#1da1f2]"
          >
            Cancel
          </button>
        </form>
      </div>
    </div>
  );
}
5. TweetCard.js

"use client";
import { useContext } from "react";
import { LikesContext } from "@/context/LikesContext";

export default function TweetCard({ tweet }) {
  const { likedTweets, toggleLike } = useContext(LikesContext);

  // All fields are now normalized
  const { id, title, body, tags, reactions, views, twitterUser } = tweet;

  return (
    <div className="border border-gray-300 rounded-lg p-4 shadow-md hover:shadow-lg transition-all cursor-pointer bg-white">
      <h2 className="text-xl font-semibold">{title}</h2>
      <p className="text-gray-700">{body || tweet.tweetContent}</p>
      <p className="text-sm text-gray-500">By: {twitterUser}</p>
      {tags.length > 0 && <p>Tags: {tags.join(", ")}</p>}
      <p>
        <span>
          üëç {reactions.likes} | üëé {reactions.dislikes}
        </span>{" "}
        <span>üëÅÔ∏è{views}</span>
      </p>
      <button
        onClick={() => toggleLike(id)}
        className={`mt-2 px-4 py-2 rounded ${
          likedTweets.includes(id)
            ? "bg-red-500 text-white"
            : "bg-gray-200"
        }`}
      >
        {likedTweets.includes(id) ? "Unlike ‚ù§Ô∏è" : "Like ‚ô°"}
      </button>
    </div>
  );
}

//models/Tweet.js
import mongoose from "mongoose";

const TweetSchema = new mongoose.Schema({
  twitterUser: {
    type: String,
    required: true,
  },
  tweetContent: {
    type: String,
    required: true,
  },
  likes: {
    type: Number,
    default: 0,
    required: false,
  },
  dislikes: {
    type: Number,
    default: 0,
    required: false,
  },
  createdAt: {
    type: Date,
    default: Date.now,
    required: true,
  },
});

// we have to define it this way because of hot reloading

/* Tweet = mongoose.models.Tweet ?? mongoose.model("Tweet", TweetSchema);
export default Tweet;
*/

export default mongoose.models.Tweet || mongoose.model('Tweet', TweetSchema);
Summary of Fixes
All tweets are normalized to a common shape before rendering.

TweetForm and handlePostSubmit now agree on the data contract (object with twitterUser and tweetContent).

TweetCard expects the normalized fields and works for both dummy and DB tweets.

API routes are consistent with the expected data.

You can now copy-paste these files into your project and everything should ‚Äútally‚Äù and work together!
Let me know if you need any further tweaks or explanations.

